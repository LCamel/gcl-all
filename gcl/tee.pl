#!/usr/bin/env perl
# tee.pl - A simple Perl script to run GCL and log input/output
# This script is mostly generated by AI.
use strict;
use warnings;
use IO::Handle;
use IPC::Open2;
use IO::Select;

# /workspaces/gcl-all/gcl/tee.pl
my $IN_LOG = 'in.log';
my $OUT_LOG = 'out.log';
my $GCL_BIN = '/home/vscode/.local/bin/gcl';

# Signal handling - ensure terminal state can be restored
my $terminal_restored = 0;
sub restore_terminal {
    return if $terminal_restored;
    system("stty sane");
    $terminal_restored = 1;
}

$SIG{INT} = $SIG{TERM} = sub {
    restore_terminal();
    exit(1);
};

# Open log files
open my $in_log,  '>', $IN_LOG or die "Cannot open $IN_LOG: $!";
open my $out_log, '>', $OUT_LOG or die "Cannot open $OUT_LOG: $!";

# Set autoflush
$in_log->autoflush(1);
$out_log->autoflush(1);
STDOUT->autoflush(1);

# Start GCL process
my $pid = open2(my $gcl_out, my $gcl_in, $GCL_BIN) or die "Cannot run $GCL_BIN: $!";

$gcl_out->autoflush(1);
$gcl_in->autoflush(1);

# Set terminal to raw mode
system("stty raw -echo");

# Set up IO::Select
my $sel = IO::Select->new();
$sel->add(\*STDIN, $gcl_out);

# Main loop
my $running = 1;
while ($running) {
    my @ready = $sel->can_read(1);  # 1秒超時
    
    unless (@ready) {
        # Check if subprocess is still running
        my $result = waitpid($pid, 1);  # WNOHANG
        if ($result > 0) {
            last;
        }
        next;
    }
    
    for my $fh (@ready) {
        if ($fh == \*STDIN) {
            my $buf;
            my $n = sysread(STDIN, $buf, 1);
            if (!defined $n) {
                warn "Error reading from STDIN: $!";
                $running = 0;
                last;
            }
            if ($n == 0) {
                # STDIN EOF
                $running = 0;
                last;
            }
            
            # Write to log and GCL
            print $in_log $buf or warn "Cannot write to in.txt: $!";
            print $gcl_in $buf or do {
                warn "Cannot write to GCL: $!";
                $running = 0;
                last;
            };
            
        } elsif ($fh == $gcl_out) {
            my $buf;
            my $n = sysread($gcl_out, $buf, 4096);
            if (!defined $n) {
                warn "Error reading from GCL: $!";
                $running = 0;
                last;
            }
            if ($n == 0) {
                # GCL output EOF
                $running = 0;
                last;
            }
            
            # Write to log and STDOUT
            print $out_log $buf or warn "Cannot write to out.txt: $!";
            print STDOUT $buf or warn "Cannot write to STDOUT: $!";
        }
    }
}

# Cleanup
restore_terminal();

close $gcl_in;
close $gcl_out;
close $in_log;
close $out_log;

waitpid($pid, 0);