#!/usr/bin/env perl
#
# tee.pl - A simple Perl script to run GCL and log input/output
#
# You can set "gcl-vscode.gclPath" TO "/workspaces/gcl-all/gcl/tee.pl"
#
# This script is mostly generated by AI.

use strict;
use warnings;
use IO::Handle;
use IPC::Open3;
use IO::Select;
use Symbol qw(gensym);
use POSIX qw(:sys_wait_h);

my $IN_LOG = 'gcl_in.log';
my $OUT_LOG = 'gcl_out.log';
my $ERR_LOG = 'gcl_err.log';
my $GCL_BIN = '/home/vscode/.local/bin/gcl';

# Signal handling
my $terminal_restored = 0;
sub restore_terminal {
    return if $terminal_restored;
    system("stty sane");
    $terminal_restored = 1;
}

$SIG{INT} = $SIG{TERM} = sub {
    restore_terminal();
    exit(1);
};

# Open log files
open my $in_log,  '>', $IN_LOG or die "Cannot open $IN_LOG: $!";
open my $out_log, '>', $OUT_LOG or die "Cannot open $OUT_LOG: $!";
open my $err_log, '>', $ERR_LOG or die "Cannot open $ERR_LOG: $!";

# Set autoflush
$in_log->autoflush(1);
$out_log->autoflush(1);
$err_log->autoflush(1);
STDOUT->autoflush(1);
STDERR->autoflush(1);

# Create separate symbol for STDERR to avoid sharing with STDOUT
my $gcl_err = gensym();

# Start GCL process
my $pid = open3(my $gcl_in, my $gcl_out, $gcl_err, $GCL_BIN) or die "Cannot run $GCL_BIN: $!";

# Set non-blocking I/O for all handles
use Fcntl qw(F_GETFL F_SETFL O_NONBLOCK);

sub set_nonblocking {
    my $fh = shift;
    my $flags = fcntl($fh, F_GETFL, 0) or die "Can't get flags: $!";
    fcntl($fh, F_SETFL, $flags | O_NONBLOCK) or die "Can't set non-blocking: $!";
}

set_nonblocking($gcl_out);
set_nonblocking($gcl_err);

# Don't set terminal to raw mode for LSP servers - they expect line-buffered input
# system("stty raw -echo");

# Set up IO::Select
my $sel = IO::Select->new();
$sel->add(\*STDIN, $gcl_out, $gcl_err);

# Main loop
my $running = 1;
while ($running) {
    # Check if child process is still running first
    my $result = waitpid($pid, WNOHANG);
    if ($result > 0) {
        # Child process has exited
        last;
    }

    my @ready = $sel->can_read(0.1);  # Short timeout

    for my $fh (@ready) {
        if ($fh == \*STDIN) {
            # Read from STDIN
            my $buf;
            my $n = sysread(STDIN, $buf, 4096);
            if (!defined $n) {
                if ($! == POSIX::EAGAIN || $! == POSIX::EWOULDBLOCK) {
                    next;
                }
                warn "Error reading from STDIN: $!";
                $running = 0;
                last;
            }
            if ($n == 0) {
                # STDIN EOF
                close $gcl_in;
                # Don't exit immediately, let GCL finish processing
                $sel->remove(\*STDIN);
                next;
            }

            # Log input and send to GCL
            print $in_log $buf or warn "Cannot write to $IN_LOG: $!";
            if ($gcl_in) {
                print $gcl_in $buf or do {
                    warn "Cannot write to GCL: $!";
                    $running = 0;
                    last;
                };
            }

        } elsif ($fh == $gcl_out) {
            # Read from GCL STDOUT
            my $buf;
            my $n = sysread($gcl_out, $buf, 4096);
            if (!defined $n) {
                if ($! == POSIX::EAGAIN || $! == POSIX::EWOULDBLOCK) {
                    next;
                }
                warn "Error reading from GCL stdout: $!";
                $running = 0;
                last;
            }
            if ($n == 0) {
                # GCL stdout EOF
                $sel->remove($gcl_out);
                next;
            }

            # Log output and send to STDOUT
            print $out_log $buf or warn "Cannot write to $OUT_LOG: $!";
            print STDOUT $buf or warn "Cannot write to STDOUT: $!";

        } elsif ($fh == $gcl_err) {
            # Read from GCL STDERR
            my $buf;
            my $n = sysread($gcl_err, $buf, 4096);
            if (!defined $n) {
                if ($! == POSIX::EAGAIN || $! == POSIX::EWOULDBLOCK) {
                    next;
                }
                warn "Error reading from GCL stderr: $!";
                # Don't exit on stderr error, just log it
                $sel->remove($gcl_err);
                next;
            }
            if ($n == 0) {
                # GCL stderr EOF
                $sel->remove($gcl_err);
                next;
            }

            # Log error output and send to STDERR
            print $err_log $buf or warn "Cannot write to $ERR_LOG: $!";
            print STDERR $buf or warn "Cannot write to STDERR: $!";
        }
    }

    # If no handles left to monitor, exit
    if ($sel->count == 0) {
        last;
    }
}

# Cleanup
restore_terminal();

# Close all handles
close $gcl_in if $gcl_in;
close $gcl_out if $gcl_out;
close $gcl_err if $gcl_err;
close $in_log;
close $out_log;
close $err_log;

# Wait for child process to finish
waitpid($pid, 0);
